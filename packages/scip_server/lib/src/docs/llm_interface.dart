import 'context_builder.dart';

/// A generated documentation result.
class GeneratedDoc {
  const GeneratedDoc({
    required this.content,
    required this.smartSymbols,
    this.title,
    this.summary,
  });

  /// The full markdown content.
  final String content;

  /// Smart symbols (scip:// URIs) referenced in the doc.
  final List<String> smartSymbols;

  /// Optional extracted title.
  final String? title;

  /// Optional extracted summary.
  final String? summary;
}

/// Summary of a folder doc (for module generation).
class FolderDocSummary {
  const FolderDocSummary({
    required this.path,
    required this.content,
    required this.summary,
    required this.smartSymbols,
  });

  final String path;
  final String content;
  final String? summary;
  final List<String> smartSymbols;
}

/// Summary of a module doc (for project generation).
class ModuleDocSummary {
  const ModuleDocSummary({
    required this.name,
    required this.content,
    required this.summary,
    required this.smartSymbols,
  });

  final String name;
  final String content;
  final String? summary;
  final List<String> smartSymbols;
}

/// Abstract interface for documentation generation.
///
/// Implementations can use different LLM providers (Anthropic, OpenAI, etc.)
/// or stub implementations for testing.
abstract class DocGenerator {
  /// Generate documentation for a folder.
  ///
  /// The [context] contains full folder info plus dependency summaries.
  Future<GeneratedDoc> generateFolderDoc(DocContext context);

  /// Generate documentation for a module (grouping of folders).
  ///
  /// The [moduleName] identifies the module.
  /// The [folders] contain the already-generated folder docs.
  Future<GeneratedDoc> generateModuleDoc(
    String moduleName,
    List<FolderDocSummary> folders,
  );

  /// Generate documentation for the entire project.
  ///
  /// The [projectName] is the project/package name.
  /// The [modules] contain the already-generated module docs.
  Future<GeneratedDoc> generateProjectDoc(
    String projectName,
    List<ModuleDocSummary> modules,
  );
}

/// Stub implementation that generates placeholder documentation.
///
/// Useful for testing the pipeline without actual LLM calls.
class StubDocGenerator implements DocGenerator {
  const StubDocGenerator();

  @override
  Future<GeneratedDoc> generateFolderDoc(DocContext context) async {
    final buffer = StringBuffer();
    final smartSymbols = <String>[];

    // Title from folder name
    final folderName = context.current.path.split('/').last;
    final title = _toTitleCase(folderName);
    buffer.writeln('# $title');
    buffer.writeln();

    // Overview section
    buffer.writeln('## Overview');
    buffer.writeln();
    buffer.writeln(
        '> This documentation was generated by the stub generator. '
        'Replace with actual LLM-generated content.');
    buffer.writeln();

    // Files section
    buffer.writeln('## Files');
    buffer.writeln();
    for (final file in context.current.files) {
      final fileName = file.path.split('/').last;
      buffer.writeln('- `$fileName`');
      for (final api in file.publicApi) {
        buffer.writeln('  - ${api.kind} [`${api.name}`][${_toAnchor(api.name)}]');
        
        // Build scip:// URI for smart symbol
        final uri = 'scip://${file.path}/${api.name}#';
        smartSymbols.add(uri);
      }
    }
    buffer.writeln();

    // Dependencies section
    if (context.internalDeps.isNotEmpty || context.externalDeps.isNotEmpty) {
      buffer.writeln('## Dependencies');
      buffer.writeln();

      if (context.internalDeps.isNotEmpty) {
        buffer.writeln('### Internal');
        for (final dep in context.internalDeps) {
          buffer.writeln('- `${dep.path}`');
          for (final sym in dep.usedSymbols) {
            buffer.writeln('  - $sym');
          }
        }
        buffer.writeln();
      }

      if (context.externalDeps.isNotEmpty) {
        buffer.writeln('### External Packages');
        for (final dep in context.externalDeps) {
          buffer.writeln('- `${dep.name}`');
          for (final sym in dep.usedSymbols) {
            buffer.writeln('  - $sym');
          }
        }
        buffer.writeln();
      }
    }

    // Smart symbol definitions
    buffer.writeln('<!-- Smart Symbol Definitions -->');
    for (final file in context.current.files) {
      for (final api in file.publicApi) {
        buffer.writeln('[${_toAnchor(api.name)}]: scip://${file.path}/${api.name}#');
      }
    }

    final summary = 'Documentation for ${context.current.path} folder.';

    return GeneratedDoc(
      content: buffer.toString(),
      smartSymbols: smartSymbols,
      title: title,
      summary: summary,
    );
  }

  @override
  Future<GeneratedDoc> generateModuleDoc(
    String moduleName,
    List<FolderDocSummary> folders,
  ) async {
    final buffer = StringBuffer();
    final smartSymbols = <String>[];

    final title = _toTitleCase(moduleName);
    buffer.writeln('# $title Module');
    buffer.writeln();

    buffer.writeln('## Overview');
    buffer.writeln();
    buffer.writeln('> Module documentation generated by stub generator.');
    buffer.writeln();

    buffer.writeln('## Components');
    buffer.writeln();
    for (final folder in folders) {
      final folderName = folder.path.split('/').last;
      buffer.writeln('- [$folderName](./folders/${folder.path}/)');
      if (folder.summary != null) {
        buffer.writeln('  - ${folder.summary}');
      }
      smartSymbols.addAll(folder.smartSymbols);
    }

    return GeneratedDoc(
      content: buffer.toString(),
      smartSymbols: smartSymbols,
      title: '$title Module',
      summary: 'Module containing ${folders.length} components.',
    );
  }

  @override
  Future<GeneratedDoc> generateProjectDoc(
    String projectName,
    List<ModuleDocSummary> modules,
  ) async {
    final buffer = StringBuffer();
    final smartSymbols = <String>[];

    buffer.writeln('# $projectName');
    buffer.writeln();

    buffer.writeln('## Overview');
    buffer.writeln();
    buffer.writeln('> Project documentation generated by stub generator.');
    buffer.writeln();

    buffer.writeln('## Modules');
    buffer.writeln();
    for (final module in modules) {
      buffer.writeln('- [${module.name}](./modules/${module.name}.md)');
      if (module.summary != null) {
        buffer.writeln('  - ${module.summary}');
      }
      smartSymbols.addAll(module.smartSymbols);
    }

    return GeneratedDoc(
      content: buffer.toString(),
      smartSymbols: smartSymbols,
      title: projectName,
      summary: 'Project with ${modules.length} modules.',
    );
  }

  /// Convert snake_case or kebab-case to Title Case.
  String _toTitleCase(String s) {
    return s
        .replaceAll('_', ' ')
        .replaceAll('-', ' ')
        .split(' ')
        .map((word) {
          if (word.isEmpty) return word;
          return word[0].toUpperCase() + word.substring(1).toLowerCase();
        })
        .join(' ');
  }

  /// Convert a name to a markdown anchor.
  String _toAnchor(String name) {
    return name.toLowerCase().replaceAll(RegExp(r'[^a-z0-9]'), '-');
  }
}
